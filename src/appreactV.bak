import React, { useState, useEffect, useRef } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import './App.css';

const ZODIAC_SIGNS = [
  'Aries', 'Taurus', 'Gemini', 'Cancer', 'Leo', 'Virgo',
  'Libra', 'Scorpio', 'Sagittarius', 'Capricorn', 'Aquarius', 'Pisces'
];

const ELEMENT_COLORS = {
  fire: 0xff6b35,    // Aries, Leo, Sagittarius
  earth: 0x6b8e23,   // Taurus, Virgo, Capricorn
  air: 0xf4e04d,     // Gemini, Libra, Aquarius
  water: 0x4a90e2    // Cancer, Scorpio, Pisces
};

const SIGN_TO_ELEMENT = {
  'Aries': 'fire', 'Leo': 'fire', 'Sagittarius': 'fire',
  'Taurus': 'earth', 'Virgo': 'earth', 'Capricorn': 'earth',
  'Gemini': 'air', 'Libra': 'air', 'Aquarius': 'air',
  'Cancer': 'water', 'Scorpio': 'water', 'Pisces': 'water'
};

export default function CosmicUniverse() {
  // Start with form closed so OrbitControls are immediately usable
  const [showForm, setShowForm] = useState(false);
  const [sunSign, setSunSign] = useState('');
  const [moonSign, setMoonSign] = useState('');
  const [risingSign, setRisingSign] = useState('');
  const [loading, setLoading] = useState(false);
  const [starCount, setStarCount] = useState(0);
  const [selectedStar, setSelectedStar] = useState(null);


  const mountRef = useRef(null);
  const sceneRef = useRef(null);
  const starsRef = useRef([]);
  const animationIdRef = useRef(null);
  const cameraRef = useRef(null);
  const rendererRef = useRef(null);

  const controlsRef = useRef(null);

  // Server URL â€” change when deploying
  const SERVER_URL = 'http://localhost:4000';

  // Simple server helpers
  const postStarToServer = async (star) => {
    const res = await fetch(`${SERVER_URL}/api/stars`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(star),
    });
    if (!res.ok) throw new Error(`Server returned ${res.status}`);
    return res.json();
  };

  const fetchStarsFromServer = async () => {
    const res = await fetch(`${SERVER_URL}/api/stars`);
    if (!res.ok) throw new Error('Failed to fetch stars from server');
    return res.json();
  };

  useEffect(() => {
    if (!mountRef.current) return;

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000200);
    scene.add(new THREE.AmbientLight(0x404040, 0.5));
    sceneRef.current = scene;

    // Camera
    const camera = new THREE.PerspectiveCamera(60, mountRef.current.clientWidth / mountRef.current.clientHeight, 0.1, 1000);
    camera.position.z = 100;
    cameraRef.current = camera;

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
    rendererRef.current = renderer;

    // Set canvas properties BEFORE appending to DOM
    renderer.domElement.style.touchAction = 'none';
    renderer.domElement.style.userSelect = 'none';

    mountRef.current.appendChild(renderer.domElement);

    // OrbitControls - attach to canvas only (safer for form interaction)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 10;
    controls.maxDistance = 200;
    controls.enabled = true;
    controlsRef.current = controls;

    // Small drag vs click detection and named handlers so we can remove them on cleanup
    let mouseDownPos = { x: 0, y: 0 };
    let isDragging = false;

    const onPointerDown = (e) => {
      mouseDownPos = { x: e.clientX, y: e.clientY };
      isDragging = false;
    };

    const onPointerMove = (e) => {
      const dx = e.clientX - mouseDownPos.x;
      const dy = e.clientY - mouseDownPos.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance > 5) isDragging = true;
    };

    const handleCanvasClick = (event) => {
      // Don't open popup if user was dragging
      if (isDragging) return;

      // Calculate mouse position in normalized device coordinates (-1 to +1)
      const rect = renderer.domElement.getBoundingClientRect();
      const mouse = new THREE.Vector2(
        ((event.clientX - rect.left) / rect.width) * 2 - 1,
        -((event.clientY - rect.top) / rect.height) * 2 + 1
      );

      // Raycasting
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);

      // Check for intersections with stars
      const intersects = raycaster.intersectObjects(starsRef.current, true);

      if (intersects.length > 0) {
        // Find the parent star mesh (not the glow)
        let starMesh = intersects[0].object;
        if (starMesh.parent && starsRef.current.includes(starMesh.parent)) {
          starMesh = starMesh.parent;
        }

        // Get the star data
        if (starMesh.userData && Object.keys(starMesh.userData).length > 0) {
          setSelectedStar(starMesh.userData);
        }
      } else {
        setSelectedStar(null);
      }
    };

    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('click', handleCanvasClick);

    // Load existing stars from server
    (async () => {
      try {
        const serverStars = await fetchStarsFromServer();
        serverStars.forEach(s => addStarToScene(s));
        setStarCount(serverStars.length);
      } catch (err) {
        console.warn('Could not load stars from server:', err);
        // fallback: no stars
        setStarCount(0);
      }
    })();

    // Animation loop
    const animate = () => {
      animationIdRef.current = requestAnimationFrame(animate);

      // Update controls for smooth damping
      controls.update();

      // Gentle pulse for stars
      starsRef.current.forEach((star, i) => {
        const time = Date.now() * 0.001;
        star.scale.setScalar(1 + Math.sin(time + i) * 0.05);
      });

      renderer.render(scene, camera);
    };
    animate();

    // Handle resize
    const handleResize = () => {
      if (!mountRef.current) return;
      camera.aspect = mountRef.current.clientWidth / mountRef.current.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
    };
    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
      // remove canvas event listeners we added
      try {
        renderer.domElement.removeEventListener('pointerdown', onPointerDown);
        renderer.domElement.removeEventListener('pointermove', onPointerMove);
        renderer.domElement.removeEventListener('click', handleCanvasClick);
      } catch (e) {
        // ignore if already removed
      }
      controls.dispose();
      if (animationIdRef.current) {
        cancelAnimationFrame(animationIdRef.current);
      }
      if (mountRef.current && renderer.domElement) {
        mountRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
    };
  }, []);

  // (loading handled from server during init)

  const addStarToScene = (starData) => {
    if (!sceneRef.current) return;

    const color = ELEMENT_COLORS[SIGN_TO_ELEMENT[starData.sunSign]];

    // Create star
    const star = new THREE.Mesh(
      new THREE.SphereGeometry(1, 32, 32),
      new THREE.MeshBasicMaterial({ color })
    );
    star.position.set(starData.position.x, starData.position.y, starData.position.z);

    // Add glow
    star.add(new THREE.Mesh(
      new THREE.SphereGeometry(1.5, 32, 32),
      new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.3 })
    ));

    // Attach star data to mesh for raycasting
    star.userData = starData;

    sceneRef.current.add(star);
    starsRef.current.push(star);
  };

  const handleSubmit = async () => {
    if (!sunSign || !moonSign || !risingSign) {
      alert('Please fill in all zodiac signs');
      return;
    }

    setLoading(true);

    const starData = {
      sunSign,
      moonSign,
      risingSign,
      position: {
        x: (Math.random() - 0.5) * 80,
        y: (Math.random() - 0.5) * 80,
        z: (Math.random() - 0.5) * 80
      },
      timestamp: Date.now()
    };

    // Send to server and only add to scene on success
    try {
      const saved = await postStarToServer(starData);
      // server returns saved star (with id)
      addStarToScene(saved);
      setStarCount(prev => prev + 1);
    } catch (err) {
      alert('Could not save star to server. Make sure the server is running.');
    }

    // Reset form
    setSunSign('');
    setMoonSign('');
    setRisingSign('');
    setShowForm(false);
    setLoading(false);

    // setTimeout(() => alert('Your star has been added!'), 100);
  };

  // Upload all localStorage stars to the local server


  return (
    <div className="app-container">
      <div ref={mountRef} className="canvas-container"></div>

      {/* UI Overlay */}
      <div className="ui-overlay">
        {/* Star counter */}
        <div className="star-counter">
          <div className="star-counter-label">Stars in Universe</div>
          <div className="star-counter-value">{starCount}</div>
        </div>

        {/* Star details popup */}
        {selectedStar && (
          <div className="star-details">
            <button
              className="star-details-close"
              onClick={() => setSelectedStar(null)}
            >
              Ã—
            </button>
            <h3 className="star-details-title">Star Details</h3>
            <div className="star-details-content">
              <div className="star-detail-item">
                <span className="star-detail-label">â˜‰ Sun Sign:</span>
                <span className="star-detail-value">{selectedStar.sunSign}</span>
              </div>
              <div className="star-detail-item">
                <span className="star-detail-label">â˜½ Moon Sign:</span>
                <span className="star-detail-value">{selectedStar.moonSign}</span>
              </div>
              <div className="star-detail-item">
                <span className="star-detail-label">â†‘ Rising Sign:</span>
                <span className="star-detail-value">{selectedStar.risingSign}</span>
              </div>
              <div className="star-detail-item">
                <span className="star-detail-label">ðŸ“… Added:</span>
                <span className="star-detail-value">
                  {new Date(selectedStar.timestamp).toLocaleDateString()}
                </span>
              </div>
            </div>
          </div>
        )}

        {/* Toggle button */}
        {!showForm && (
          <button
            onClick={() => setShowForm(true)}
            className="add-star-button"
          >
            Add Your Star
          </button>
        )}

        {/* sync removed */}

        {/* Form overlay */}
        {showForm && (
          <div className="form-overlay">
            <div className="form-container">
              <div className="form-header">
                <h2 className="form-title">Add Your Star</h2>
                <button
                  onClick={() => setShowForm(false)}
                  className="close-button"
                >
                  Ã—
                </button>
              </div>

              <div className="form-content">
                <div className="form-group">
                  <label className="form-label">
                    Sun Sign
                  </label>
                  <select
                    value={sunSign}
                    onChange={(e) => setSunSign(e.target.value)}
                    className="form-select"
                  >
                    <option value="">Select...</option>
                    {ZODIAC_SIGNS.map(sign => (
                      <option key={sign} value={sign}>{sign}</option>
                    ))}
                  </select>
                </div>
                <div className="form-group">
                  <label className="form-label">
                    Moon Sign
                  </label>
                  <select
                    value={moonSign}
                    onChange={(e) => setMoonSign(e.target.value)}
                    className="form-select"
                  >
                    <option value="">Select...</option>
                    {ZODIAC_SIGNS.map(sign => (
                      <option key={sign} value={sign}>{sign}</option>
                    ))}
                  </select>
                </div>

                <div className="form-group">
                  <label className="form-label">
                    Rising Sign
                  </label>
                  <select
                    value={risingSign}
                    onChange={(e) => setRisingSign(e.target.value)}
                    className="form-select"
                  >
                    <option value="">Select...</option>
                    {ZODIAC_SIGNS.map(sign => (
                      <option key={sign} value={sign}>{sign}</option>
                    ))}
                  </select>
                </div>

                <button
                  onClick={handleSubmit}
                  disabled={loading}
                  className="submit-button"
                >
                  {loading ? 'Adding Star...' : 'Add'}
                </button>
              </div>

              <p className="form-footer">
                Your star will be visible to everyone exploring the cosmic universe
              </p>
            </div>
          </div>
        )}
      </div>
    </div>
  );
} 